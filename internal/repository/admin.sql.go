// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package repository

import (
	"context"
	"time"
)

const getURLs = `-- name: GetURLs :many
SELECT
  id,
  long_url,
  created_at,
  is_custom,
  user_id,
  COUNT(*) OVER () as total_count
FROM
  urls
ORDER BY
  created_at DESC
LIMIT
  $2
OFFSET
  $1
`

type GetURLsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type GetURLsRow struct {
	ID         string    `json:"id"`
	LongUrl    string    `json:"longUrl"`
	CreatedAt  time.Time `json:"createdAt"`
	IsCustom   bool      `json:"isCustom"`
	UserID     *string   `json:"userId"`
	TotalCount int64     `json:"totalCount"`
}

// GetURLs
//
//	SELECT
//	  id,
//	  long_url,
//	  created_at,
//	  is_custom,
//	  user_id,
//	  COUNT(*) OVER () as total_count
//	FROM
//	  urls
//	ORDER BY
//	  created_at DESC
//	LIMIT
//	  $2
//	OFFSET
//	  $1
func (q *Queries) GetURLs(ctx context.Context, arg GetURLsParams) ([]GetURLsRow, error) {
	rows, err := q.db.Query(ctx, getURLs, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetURLsRow{}
	for rows.Next() {
		var i GetURLsRow
		if err := rows.Scan(
			&i.ID,
			&i.LongUrl,
			&i.CreatedAt,
			&i.IsCustom,
			&i.UserID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
